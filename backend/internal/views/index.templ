package views

import "backend/internal/models"

templ Index(articles []models.ArticleInfo, config *models.Configuration) {
	<!DOCTYPE html>
	<html lang="en">
		<head>
			<meta charset="UTF-8"/>
			<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
			<title>{ config.AuthorName }'s Blog</title>
			<link rel="apple-touch-icon" sizes="180x180" href="static/apple-touch-icon.png"/>
			<link rel="icon" type="image/png" sizes="32x32" href="static/favicon-32x32.png"/>
			<link rel="icon" type="image/png" sizes="16x16" href="static/favicon-16x16.png"/>
			<link rel="manifest" href="static/site.webmanifest"/>
			<link rel="stylesheet" href="static/styles.css"/>
		</head>
		<body>
			<header class="blog-header">
				> { config.AuthorName }'s Blog<span class="terminal-cursor"></span>
			</header>
			<main>
				<div id="articles-container">
					@ArticlesInfo(articles)
				</div>
				<div id="loading" class="loading">
					Loading more articles...
				</div>
				<div id="end-marker"></div>
			</main>
			<script>
				const articlesContainer = document.getElementById('articles-container');
				const loadingIndicator = document.getElementById('loading');
				const endMarker = document.getElementById('end-marker');

				let currentPage = 1;
				let isLoading = false;
				let hasMorePages = getArticlesCount() % 10 == 0;

				// Intersection Observer for infinite scroll
				const observer = new IntersectionObserver((entries) => {
					entries.forEach(entry => {
						if (entry.isIntersecting && !isLoading && hasMorePages) {
							loadMoreArticles();
						}
					});
				}, {
					rootMargin: '200px' // Start loading 200px before the marker comes into view
				});

				observer.observe(endMarker);

                function getArticlesCount(){
                    const articleElements = articlesContainer.querySelectorAll('.article-item');
                    return articleElements.length;
                }

				async function loadMoreArticles() {
					if (isLoading || !hasMorePages) return;
					
					isLoading = true;
					loadingIndicator.classList.add('show');
					
					try {
						const response = await fetch(`/info?page=${currentPage + 1}`);
						
						if (!response.ok) {
							throw new Error(`HTTP error! status: ${response.status}`);
						}
						
						const html = await response.text();
						
						// If response is empty, we've reached the end
						if (html.trim().length === 0) {
							hasMorePages = false;
							observer.disconnect();
							loadingIndicator.textContent = 'No more articles to load';
							setTimeout(() => {
								loadingIndicator.classList.remove('show');
							}, 2000);
							return;
						}
						
						// Create a temporary container to parse the HTML
						const tempDiv = document.createElement('div');
						tempDiv.innerHTML = html;
						
						// Count the number of article elements returned
						const articleElements = tempDiv.querySelectorAll('.article-item');
						const articlesCount = articleElements.length;
						
						// If we got fewer than 10 articles, we've reached the end
						if (articlesCount < 10) {
							hasMorePages = false;
							observer.disconnect();
						}
						
						// Append all article elements to the main container
						while (tempDiv.firstChild) {
							articlesContainer.appendChild(tempDiv.firstChild);
						}
						
						// Show end message if this was the last page
						if (!hasMorePages) {
							loadingIndicator.textContent = 'No more articles to load';
							setTimeout(() => {
								loadingIndicator.classList.remove('show');
							}, 2000);
						}
						
						currentPage++;
						
					} catch (error) {
						console.error('Error loading more articles:', error);
						loadingIndicator.textContent = 'Error loading articles. Please try refreshing the page.';
						hasMorePages = false;
						setTimeout(() => {
							loadingIndicator.classList.remove('show');
						}, 4000);
					} finally {
						isLoading = false;
						if (hasMorePages) {
							loadingIndicator.classList.remove('show');
						}
					}
				}

				// Optional: Add smooth scroll behavior for better UX
				// document.documentElement.style.scrollBehavior = 'smooth';
			</script>
		</body>
	</html>
}
