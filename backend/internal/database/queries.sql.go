// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.30.0
// source: queries.sql

package database

import (
	"context"
	"database/sql"
	"time"
)

const addArticleRead = `-- name: AddArticleRead :exec
INSERT INTO
    article_reads (article_id)
SELECT
    id
FROM
    articles
WHERE
    filename = ?
`

func (q *Queries) AddArticleRead(ctx context.Context, filename string) error {
	_, err := q.db.ExecContext(ctx, addArticleRead, filename)
	return err
}

const clearArticleTags = `-- name: ClearArticleTags :exec
DELETE FROM
    article_tags
WHERE
    article_id = ?
`

func (q *Queries) ClearArticleTags(ctx context.Context, articleID int64) error {
	_, err := q.db.ExecContext(ctx, clearArticleTags, articleID)
	return err
}

const createArticle = `-- name: CreateArticle :one
INSERT INTO
    articles (title, filename, description, body)
VALUES
    (?, ?, ?, ?) RETURNING ID
`

type CreateArticleParams struct {
	Title       string
	Filename    string
	Description string
	Body        string
}

// Article CRUD Operations
func (q *Queries) CreateArticle(ctx context.Context, arg CreateArticleParams) (int64, error) {
	row := q.db.QueryRowContext(ctx, createArticle,
		arg.Title,
		arg.Filename,
		arg.Description,
		arg.Body,
	)
	var id int64
	err := row.Scan(&id)
	return id, err
}

const createArticleTag = `-- name: CreateArticleTag :exec
INSERT INTO
    article_tags (article_id, tag_name)
VALUES
    (?, ?)
`

type CreateArticleTagParams struct {
	ArticleID int64
	TagName   string
}

func (q *Queries) CreateArticleTag(ctx context.Context, arg CreateArticleTagParams) error {
	_, err := q.db.ExecContext(ctx, createArticleTag, arg.ArticleID, arg.TagName)
	return err
}

const createTag = `-- name: CreateTag :exec
INSERT
    OR IGNORE INTO tags (name)
VALUES
    (?)
`

// Create tag
func (q *Queries) CreateTag(ctx context.Context, name string) error {
	_, err := q.db.ExecContext(ctx, createTag, name)
	return err
}

const getArticle = `-- name: GetArticle :one
SELECT
    id,
    title,
    filename,
    description,
    body,
    created_at,
    updated_at,
    scheduled_at,
    published_at,
    deleted_at
FROM
    articles
WHERE
    id = ?
LIMIT
    1
`

func (q *Queries) GetArticle(ctx context.Context, id int64) (Article, error) {
	row := q.db.QueryRowContext(ctx, getArticle, id)
	var i Article
	err := row.Scan(
		&i.ID,
		&i.Title,
		&i.Filename,
		&i.Description,
		&i.Body,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.ScheduledAt,
		&i.PublishedAt,
		&i.DeletedAt,
	)
	return i, err
}

const getArticleInfos = `-- name: GetArticleInfos :many
SELECT
    id,
    title,
    filename,
    description,
    created_at,
    updated_at,
    scheduled_at,
    published_at
FROM
    articles
LIMIT
    ? OFFSET ?
`

type GetArticleInfosParams struct {
	Limit  int64
	Offset int64
}

type GetArticleInfosRow struct {
	ID          int64
	Title       string
	Filename    string
	Description string
	CreatedAt   time.Time
	UpdatedAt   time.Time
	ScheduledAt sql.NullTime
	PublishedAt sql.NullTime
}

func (q *Queries) GetArticleInfos(ctx context.Context, arg GetArticleInfosParams) ([]GetArticleInfosRow, error) {
	rows, err := q.db.QueryContext(ctx, getArticleInfos, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetArticleInfosRow
	for rows.Next() {
		var i GetArticleInfosRow
		if err := rows.Scan(
			&i.ID,
			&i.Title,
			&i.Filename,
			&i.Description,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.ScheduledAt,
			&i.PublishedAt,
		); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleTags = `-- name: GetArticleTags :many
SELECT
    tag_name
FROM
    article_tags
WHERE
    article_id = ?
`

func (q *Queries) GetArticleTags(ctx context.Context, articleID int64) ([]string, error) {
	rows, err := q.db.QueryContext(ctx, getArticleTags, articleID)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []string
	for rows.Next() {
		var tag_name string
		if err := rows.Scan(&tag_name); err != nil {
			return nil, err
		}
		items = append(items, tag_name)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getArticleTitle = `-- name: GetArticleTitle :one
SELECT
    title
FROM
    articles
WHERE
    id = ?
`

func (q *Queries) GetArticleTitle(ctx context.Context, id int64) (string, error) {
	row := q.db.QueryRowContext(ctx, getArticleTitle, id)
	var title string
	err := row.Scan(&title)
	return title, err
}

const getScheduledArticleTimes = `-- name: GetScheduledArticleTimes :many
SELECT
    id,
    scheduled_at
FROM
    articles
WHERE
    scheduled_at IS NOT NULL
    AND scheduled_at > CURRENT_TIMESTAMP
    OR (published_at IS NULL)
    AND deleted_at IS NULL
`

type GetScheduledArticleTimesRow struct {
	ID          int64
	ScheduledAt sql.NullTime
}

func (q *Queries) GetScheduledArticleTimes(ctx context.Context) ([]GetScheduledArticleTimesRow, error) {
	rows, err := q.db.QueryContext(ctx, getScheduledArticleTimes)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []GetScheduledArticleTimesRow
	for rows.Next() {
		var i GetScheduledArticleTimesRow
		if err := rows.Scan(&i.ID, &i.ScheduledAt); err != nil {
			return nil, err
		}
		items = append(items, i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const publishArticle = `-- name: PublishArticle :exec
UPDATE
    articles
SET
    published_at = CURRENT_TIMESTAMP
WHERE
    id = ?
`

func (q *Queries) PublishArticle(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, publishArticle, id)
	return err
}

const setArticleDeleted = `-- name: SetArticleDeleted :exec
UPDATE
    articles
SET
    deleted_at = CURRENT_TIMESTAMP
WHERE
    id = ?
`

func (q *Queries) SetArticleDeleted(ctx context.Context, id int64) error {
	_, err := q.db.ExecContext(ctx, setArticleDeleted, id)
	return err
}

const updateArticle = `-- name: UpdateArticle :exec
UPDATE
    articles
SET
    title = ?,
    filename = ?,
    description = ?,
    body = ?,
    updated_at = CURRENT_TIMESTAMP,
    scheduled_at = ?,
    published_at = ?
WHERE
    id = ?
`

type UpdateArticleParams struct {
	Title       string
	Filename    string
	Description string
	Body        string
	ScheduledAt sql.NullTime
	PublishedAt sql.NullTime
	ID          int64
}

func (q *Queries) UpdateArticle(ctx context.Context, arg UpdateArticleParams) error {
	_, err := q.db.ExecContext(ctx, updateArticle,
		arg.Title,
		arg.Filename,
		arg.Description,
		arg.Body,
		arg.ScheduledAt,
		arg.PublishedAt,
		arg.ID,
	)
	return err
}
